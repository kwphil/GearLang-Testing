// <gearlang/token> -*- C++ -*-

// This file is part of the GearLang v0.0.1 executable. This library is free
// software; you can redistribute it and/or modify it under the terms
// of the GNU General Public License as published by the Free Software
// Foundation; either version 3, or (at your option) any later version.

// This executable is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details. 

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

#pragma once

#include <functional>
#include <optional>
#include <string> 
#include <tuple>

/**
 * Token namespace
 * 
 * A namespace of classes/types to simplify and abstract the
 * nuances of the parse
 */
namespace Token {
    /**
     * A Result that either returns nothing, 
     * or a tuple of the return value and the rest of the input
     */
    template <typename T>
    using Result = std::optional<std::tuple<T, std::string>>;

    /**
     * Base token class
     * If you really want to define a new token, you can
     * derive here to use it.
     */
    class Base {
    public:
        /**
         * Gets the value of the type
         * 
         * @example 
         * auto parser = Parser("42");
         * auto num = parser.parse();
         * std::cout << num.get_value() << std::endl;
         */
        template <typename T> 
        T get_value();

        /**
         * Gets the type of token in a human-readable format
         */
        std::string get_type();

        /**
         * Attempts to parse the token in a human readable format
         */
        template <typename T>
        static Token::Result<T> try_parse(std::string& input);
    };

    static const std::vector<std::function<Token::Result<Token::Base>(std::string&)>> 
    PARSERS {
        Number::try_parse,
    };
}

class Number : public Token::Base {
private:
    int value;

public: 
    Number(int value) {
        (*this).value = value;
    }

    // If can't parse, it will throw a null
    static Token::Result<Number> try_parse(std::string& input) {
        std::string ret = "";
        std::string::iterator it;
        
        for(it = input.begin(); it < input.end(); ++it) {
            char c = *it;

            if(!std::isdigit(c)) {
                break;
            }

            ret.push_back(c);
        }

        /* If no chars were parsed return null */
        if(ret == "") {
            return std::nullopt;
        }

        auto ret_wrap = std::make_tuple(Number(std::stoi(ret)), std::string(it, input.end()));
        return std::make_optional(ret_wrap);
    }

    int get_value() {
        return value;
    }

    std::string get_type() {
        return "Number";    
    }
};
